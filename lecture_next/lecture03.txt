### nextJS ver13
1. 서버 컴포넌트 vs 클라이언트 컴포넌트
    - 사용자와 상호작용이 발생되는 구간들은 클라이언트 컴포넌트로 구성
    - 이외에는 서버 컴포넌트 (ex. 정보 전달용도의 데이터)

    * 서버 컴포넌트가 디폴트값이며, 클라이언트 컴포넌트를 사용하기 위해서는
      "use client" string을 import문 위에 작성(알아보기 쉽게)한다.

    * 서버 컴포넌트에서는 클라이언트 컴포넌트에서 사용하는 api를 사용할 수 없다.
      "useState", "useEffect", "onClick", "onChange", "useRouter", "useParams"...

    * 클라이언트 컴포넌트로 구현된 코드 중 CSR 방식처럼 api로 처리된 동적인 코드들은
      클라이언트에서 구성하기 때문에 자바스크립트 엔진없이는 화면에 렌더링이 불가하다.
      
      > 반대로 서버 컴포넌트는 .next 폴더에 저장되어 서버에서 html을 불러오는 SSR 방식이기 때문에
        자바스크립트 엔진이 사용되지 않아도 화면에 출력된다.
      
2. 동적 서버 라우팅 : db.json *
    - NextJS와 별개로 알게된 정보이다. json-server 형태로 구성된 json은 기본적으로 프로퍼티가
      주제별로 작성되고, 해당 프로퍼티가 많은 정보를 보유한 경우에는 객체 배열을 사용하는 경우가 있다.
      그 때, 배열 내 객체에서 고유값이 동적으로 생성되는 경우가 있다면, 예를 들어 id와 같은 값...
      해당 id값은 해당 객체를 담고있는 라우팅 정보가 된다. 즉, 해당 id는 path의 segment로서 역할을 한다.

3. 캐시 ***
    - 넥스트 JS는 처음 보관된 정보를 저장(캐싱)해둔다.
        > 새로운 캐시값을 확인하기 위해서는 .next 폴더를 삭제하고 재설치하면 처음 보관된 기본값이
          새로 저장된 값이 되어 업데이트된 정보를 기반으로 화면에 출력하게 된다. => 물론 이렇게 관리하지 않습니다... XXX (Next 캐싱 특성에 대한 정의)
        > 터미널에서 cache값의 상태를 확인해주는 데 cache: HIT => 캐시 사용 / cache: MISS => 캐시 미사용으로 출력된다.

    - 캐시 관리 사용법 (공식 문서를 꼼꼼히 일어봐야할 중요한 요소) ***
        > 데이터를 패칭하는 함수에서 option값을 설정
            1) revalidate
            { next : { revalidate : 초 단위 }}
            // 캐시를 초 단위로 관리하겠다. => 0이라면 { cache : "no-store" }랑 동일한 설정
            // 서비스하는 영역에 따라 캐시를 얼만큼 쌓아놓을 건지에 따라 서비스 퍼포먼스의 향상에 직결

            2) cache
            { cache : "no-store" }
            // 캐시를 저장하지 않겠다는 선언